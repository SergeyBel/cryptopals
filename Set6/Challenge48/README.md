Задание посвящено атаке Bleichenbacher's PKCS 1.5  

## Формат PKCS 1.5   
Используется RSA с параметрами e, d, n. Длина n в байтах равна k   
Если нужно передать сообщение data длины d байт, то сообщение PKCS 1.5 будет выглядеть так:  
00h 02h padding 00h data, где:  
00h 02h  - фиксированное начало  
padding - заполнение случайными ненулевыми байтами длины k - 3 - D  
00h - нулевой байт - признак начала данных  
data - данные  
Общая длина сообщения равна в точности k 

Сообщение превращается в целое число $m_0$ и шифруется $c = m_0^e \pmod n$


## Общая идея  
Атака основана на оракуле, который возникает, если при расшифровке сообщения и парсинге, в случае, если два первых байта не равны 00h 02h, сразу выдаётся какая-то особая ошибка.  
Тогда в случае наличия этой ошибки, мы знаем, что первые два байта расшифрованного сообщения не равны 00h 02h, а в случае отстствия, что они равны 00h 02h (в этом случае будем говорить, что оракул опознал сообщение)


Обозначим $B = 2^{8(k-2)}$,  в виде байт $B$ будет иметь вид 00h 01h 00h ... 00h  
Так как в сообщении $m_0$ первые два байта равны 00h 02h, то известно, что
1. $2B \le m_0$, так как $2B$ имеет вид 00h 02h 00h ... 00h
2. $m_0 \ge 3B$, так как $3B$ имеет вид 00h 03h 00h ... 00h 

$2B \le m_0 \le 3B$  

Зная $c$ мы можем составить сообщение $c_1 = m_1^d \pmod n = (m_0 * s)^e \pmod n = c * s^e \pmod n$  
Если оракул опознал сообщение $c_1$, то первые два байта в $m_1 = c_1 ^ d \pmod n$ равны 00h 02h, тогда
$2B \le m_1 \le 3B$  
$2B \le m_0s - rn \le 3B$, для любых целых r  
$(2B + rn) / s \le m_0 \le (3B + rn) / s$  
Что даёт новые ограничения для $m_0$. Эти ограничения уточняют исходное ограничение $2B \le m_0 \le 3B$  
Повторяя итеративно этот процесс получаем одно возможное значение $m_0$  


## Алгоритм
1. Полагаем $M = ([2B, 3B])$. Ищем $s_1$ такое, что сообщение $c_1 = s_1^e * m_0 \pmod n$  будет принято оракулом    
В силу того, что $r = (m_0s_1 - m_1) / n$   $r \le (3Bs_1 - 2B) / n = (3Bs_1) / n$, чтобы $r \ge 1$ должно выполняться $s > n / (3B)$ -  это значение $s_1$ используем как отправную точку
2. По $s_1$ получаем ограничения $(2B + rn) / s_1 \le m_0 \le (3B + rn) / s_1$  
3. Строим пересечение полученных ограничений с текущими ограничениями  (Step 3 в работе Bleichenbacher есть ни что иное, как математически записанное пересечение всех отрезков).

Далее возможны три случая:
4. $M$ состоит из более чем одного отрезка. В этом случае мы находим значение $s_{i + 1} > s_i$, получаем ограничения и переходим на шаг 3.
5. $M$ состоит ровно из одного отрезка, который состоит из одной точки. Тогда мы нашли $m_0$
6. $M$ состоит ровно из одного отрезка $[a, b]$. Тогда применяется небольшая оптимизация поиска:
$s_i$ находится такое, что и $ (2B + r_in) / b \le s_i \le (3B + r_in) / a$. При этом $r_i \ge (2bs_{i - 1} - 2B) / n$ получаем ограничения и переходим на шаг 3.

В этом случае $s_i \ge (2B + r_in) / b \ge (2B + 2bs_{i-1} - 2B) / b \ge 2s_i$  Так как длина отрезка для $m_0$ обратно пропорциональна $s$ эта оптимизация позволяет экспоненциально уменьшать длину отрезка при поиске




















