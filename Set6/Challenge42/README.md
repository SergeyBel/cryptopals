Задание демонтсрирует атаку Bleichenbacher на PKCS1.5 RSA e = 3  

## Формат сообщения  
По стандарту сообщение PKCS1.5 имеет вид вид:   
00h 01h ffh ffh ... ffh ffh 00h ASN.1 HASH, где  
ASN.1 - служебная информация, определяющая хэш-функцию  
HASH - хэш исходного сообщения  

длина сообщения должна быть равна длине `n` в байтах (это обеспечивается нужным количнством байтов ffh)  

## Подпись сообщения
Подписанный пакет формируется так:
1. пакет представляется в виде числа `m`
2. подписывается (шифруется) RSA $s = m^d \pmod n)$

При проверке подпись пакет расшифровывается $m = s^e \pmod n$, затем проверяется хэш сообщения  

##Атака
Атака становится возможной из-за частой ошибки при разборе пакета, алгоритм разбора с ошибкой:
1. Найти байты 00h 01h
2. Найти следующий за ними байт 00h
3. Разобрать ASN.1, узнать длину хэша
4. Получить нужное количество байт хэша
5. Сверить хэш

Ошибка состоит в том, что длина сообщения не проверяется. Поэтому пакеты вида 00h 01h ... 00h ASN.1 HASH SOMEBYTES также будут успешно разобраны парсером

Чтобы подделать подпись нам необходимо получить такое сообщение, чтобы при возведении его в куб оно имело вид 00h 01h ... 00h ASN.1 HASH SOMEBYTES  
В задании описано два способа это сделать
1. Метод,записанный со слов Bleichenbacher
2. Реализовать целочисленный кубический корень  

Первый метод https://mailarchive.ietf.org/arch/msg/openpgp/5rnE9ZRN1AokBVj3VqblGlP63QE/ я не понял, если вы разобрались, то напишите issue, можно будет реализовать атаку и этим методом

## Решение 
1. Реализуем целочисленный корень. Моя реализация - это простая реализация на основе бинарного поиска
1. Составляем сообщение 00h 01h 00h ASN.1 HASH 00h...00h
1. Берём кубический корень из него. Сообщение при этом не обязательно должно иметь целый корень, нам подойдёт неточное значение. При возведении в куб мы получим сообщение
1. вида 00h 01h 00h ASN.1 HASH 00h...00h BYTES, которое нас также устраивает
1. Это число передаём в качестве подписи 

